###############################################################################
#                                                                             #
#                                                       13/May/2009  07:36:18 #
# IAR C/C++ Compiler V4.20.1.20017/W32, Evaluation edition for MSP430         #
# Copyright 1996-2008 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Exam #
#                     ples\Applications\main_LinkTo.c                         #
#    Command line  =  -f "C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\ #
#                     Examples\eZ430RF\Simple_Peer_to_Peer\IAR\Configuration\ #
#                     End_Device\smpl_config.dat" (-DNUM_CONNECTIONS=2        #
#                     -DSIZE_INFRAME_Q=2 -DSIZE_OUTFRAME_Q=2                  #
#                     "-DTHIS_DEVICE_ADDRESS={0x79, 0x56, 0x34, 0x12}"        #
#                     -DEND_DEVICE) -f "C:\Texas                              #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\eZ43 #
#                     0RF\Simple_Peer_to_Peer\IAR\Configuration\smpl_nwk_conf #
#                     ig.dat" (-DMAX_HOPS=3 -DMAX_HOPS_FROM_AP=1              #
#                     -DMAX_NWK_PAYLOAD=9 -DMAX_APP_PAYLOAD=10                #
#                     -DDEFAULT_LINK_TOKEN=0x01020304                         #
#                     -DDEFAULT_JOIN_TOKEN=0x05060708 -DxFREQUENCY_AGILITY    #
#                     -DxAPP_AUTO_ACK -DxEXTENDED_API -DxSMPL_SECURE          #
#                     -DxNVOBJECT_SUPPORT -DSW_TIMER) "C:\Texas               #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\Appl #
#                     ications\main_LinkTo.c" -D MRFI_CC2500 -lcN "C:\Texas   #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\eZ43 #
#                     0RF\Simple_Peer_to_Peer\IAR\CC2500-LinkTo\List\" -o     #
#                     "C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Exa #
#                     mples\eZ430RF\Simple_Peer_to_Peer\IAR\CC2500-LinkTo\Obj #
#                     \" --require_prototypes --debug -D__MSP430F2274__ -e    #
#                     --double=32 -I "C:\Texas Instruments\SimpliciTI-IAR-1.1 #
#                     .0\Projects\Examples\eZ430RF\Simple_Peer_to_Peer\IAR\.. #
#                     \..\..\..\..\Components\bsp\" -I "C:\Texas              #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\eZ43 #
#                     0RF\Simple_Peer_to_Peer\IAR\..\..\..\..\..\Components\b #
#                     sp\drivers\" -I "C:\Texas Instruments\SimpliciTI-IAR-1. #
#                     1.0\Projects\Examples\eZ430RF\Simple_Peer_to_Peer\IAR\. #
#                     .\..\..\..\..\Components\bsp\boards\EZ430RF\" -I        #
#                     "C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Exa #
#                     mples\eZ430RF\Simple_Peer_to_Peer\IAR\..\..\..\..\..\Co #
#                     mponents\mrfi\" -I "C:\Texas                            #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\eZ43 #
#                     0RF\Simple_Peer_to_Peer\IAR\..\..\..\..\..\Components\S #
#                     impliciTI\nwk\" -I "C:\Texas                            #
#                     Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\eZ43 #
#                     0RF\Simple_Peer_to_Peer\IAR\..\..\..\..\..\Components\S #
#                     impliciTI\nwk_applications\" -I "C:\Program Files\IAR   #
#                     Systems\Embedded Workbench 5.3 Evaluation\430\INC\" -I  #
#                     "C:\Program Files\IAR Systems\Embedded Workbench 5.3    #
#                     Evaluation\430\INC\CLIB\" -Ohz                          #
#    List file     =  C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Exam #
#                     ples\eZ430RF\Simple_Peer_to_Peer\IAR\CC2500-LinkTo\List #
#                     \main_LinkTo.lst                                        #
#    Object file   =  C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Exam #
#                     ples\eZ430RF\Simple_Peer_to_Peer\IAR\CC2500-LinkTo\Obj\ #
#                     main_LinkTo.r43                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\SimpliciTI-IAR-1.1.0\Projects\Examples\Applications\main_LinkTo.c
      1          /*----------------------------------------------------------------------------
      2           *  Demo Application for SimpliciTI 
      3           * 
      4           *  L. Friedman 
      5           *  Texas Instruments, Inc.
      6           *---------------------------------------------------------------------------- */
      7          
      8          /********************************************************************************************
      9            Copyright 2007-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights granted under
     12            the terms of a software license agreement between the user who downloaded the software,
     13            his/her employer (which must be your employer) and Texas Instruments Incorporated (the
     14            "License"). You may not use this Software unless you agree to abide by the terms of the
     15            License. The License limits your use, and you acknowledge, that the Software may not be
     16            modified, copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio frequency
     18            transceiver, which is integrated into your product. Other than for the foregoing purpose,
     19            you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
     20            perform, display or sell this Software and/or its documentation for any purpose.
     21          
     22            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS?  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
     23            WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
     24            IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     25            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
     26            THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
     27            INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
     28            DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
     29            THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     30          
     31            Should you have any questions regarding your right to use this Software,
     32            contact Texas Instruments Incorporated at www.TI.com.
     33          **************************************************************************************************/
     34          
     35          #include "bsp.h"
     36          #include "mrfi.h"
     37          #include "nwk_types.h"
     38          #include "nwk_api.h"
     39          #include "bsp_leds.h"
     40          #include "bsp_buttons.h"
     41          
     42          #include "app_remap_led.h"
     43          
     44          #define LED_GREEN_IS_ON	BSP_LED1_IS_ON
     45          #define LED_RED_IS_ON 	BSP_LED2_IS_ON
     46          #define	GREEN	1
     47          #define	RED		2
     48          #define	BSP_BUTTON		BSP_BUTTON1
     49          static void linkTo(void);
     50          
     51          void toggleLED(uint8_t);
     52          
     53          static uint8_t  sTxTid=0, sRxTid=0;
     54          static linkID_t sLinkID1 = 0;
     55          
     56          /* application Rx frame handler. */
     57          static uint8_t sRxCallback(linkID_t);
     58          
     59          #define SPIN_ABOUT_A_SECOND  NWK_DELAY(1000)
     60          #define SPIN_ABOUT_20_MSECOND  NWK_DELAY(20)
     61          
     62          
     63          void main (void)
     64          {
     65            BSP_Init();
     66          
     67            /* If an on-the-fly device address is generated it must be done before the
     68             * call to SMPL_Init(). If the address is set here the ROM value will not 
     69             * be used. If SMPL_Init() runs before this IOCTL is used the IOCTL call 
     70             * will not take effect. One shot only. The IOCTL call below is conformal. 
     71             */
     72          #ifdef I_WANT_TO_CHANGE_DEFAULT_ROM_DEVICE_ADDRESS_PSEUDO_CODE
     73            {
     74              addr_t lAddr;
     75          
     76              createRandomAddress(&lAddr);
     77              SMPL_Ioctl(IOCTL_OBJ_ADDR, IOCTL_ACT_SET, &lAddr);
     78            }
     79          #endif /* I_WANT_TO_CHANGE_DEFAULT_ROM_DEVICE_ADDRESS_PSEUDO_CODE */
     80          
     81            /* This call will fail because the join will fail since there is no Access Point 
     82             * in this scenario. But we don't care -- just use the default link token later. 
     83             * We supply a callback pointer to handle the message returned by the peer. 
     84             */
     85            SMPL_Init(sRxCallback);
     86          /* turn on led green, and turn off led red */
     87            if (!LED_GREEN_IS_ON())
     88            {
     89              toggleLED(GREEN);
     90            }
     91            
     92            if (LED_RED_IS_ON())
     93            {
     94              toggleLED(RED);
     95            }
     96            /* turn on LEDs. 
     97            if (!BSP_LED2_IS_ON())
     98            {
     99              toggleLED(2);
    100            }
    101            if (!BSP_LED1_IS_ON())
    102            {
    103              toggleLED(1);
    104            }
    105            */
    106          
    107            /* wait for a button press... 
    108            do {
    109              if (BSP_BUTTON1() || BSP_BUTTON2())
    110              {
    111                break;
    112              }
    113            } while (1);
    114            */
    115          
    116            /* never coming back... */
    117            linkTo();
    118          
    119            /* but in case we do... */
    120            while (1) ;
    121          }
    122          
    123          static void linkTo()
    124          {
    125            uint8_t  msg[1], delay = 0;
    126          
    127            while (SMPL_SUCCESS != SMPL_Link(&sLinkID1))
    128            {
    129              /* blink LEDs until we link successfully */
    130              toggleLED(RED);
    131              SPIN_ABOUT_A_SECOND;
    132            }
    133          
    134            /* we're linked. turn off red LED. received messages will toggle the green LED. */
    135            if (LED_RED_IS_ON())
    136            {
    137              toggleLED(RED);
    138            }
    139          
    140            /* turn on RX. default is RX off. */
    141            SMPL_Ioctl( IOCTL_OBJ_RADIO, IOCTL_ACT_RADIO_RXON, 0);
    142          
    143            /* put LED to toggle in the message */
    144            //msg[0] = 2;  /* toggle red */
    145            while (1)
    146            {
    147            
    148            		static uint8_t  alarmed=0;
    149          	  if (BSP_BUTTON())
    150          	  {
    151          		SPIN_ABOUT_20_MSECOND;	
    152          		if(BSP_BUTTON())
    153          		{
    154          			if (!LED_RED_IS_ON())
    155          			{
    156          			  toggleLED(RED);
    157          			}
    158          			msg[0]=0x01;
    159          			/* put the sequence ID in the message */
    160          			SMPL_Send(sLinkID1, msg, sizeof(msg));
    161          			
    162          			alarmed = 1;
    163          		}
    164          	  }
    165          	  else
    166          	  {
    167          		  if (LED_RED_IS_ON())
    168          		  {
    169          			toggleLED(RED);
    170          		  }
    171          		  if(alarmed)
    172          		  	{
    173          			  msg[0]=0x00;
    174          			  /* put the sequence ID in the message */
    175          			  SMPL_Send(sLinkID1, msg, sizeof(msg));
    176          
    177          				alarmed = 0;
    178          		  	}
    179          	  }
    180            }
    181          }
    182          
    183          
    184          void toggleLED(uint8_t which)
    185          {
    186            if (1 == which)
    187            {
    188              BSP_TOGGLE_LED1();
    189            }
    190            else if (2 == which)
    191            {
    192              BSP_TOGGLE_LED2();
    193            }
    194            return;
    195          }
    196          static uint8_t sRxCallback(linkID_t port)
    197          {
    198          	
    199          	return 1;
    200          }
    201          /* handle received frames. */
    202          static uint8_t sRxCallback1(linkID_t port)
    203          {
    204            uint8_t msg[2], len, tid;
    205          
    206            /* is the callback for the link ID we want to handle? */
    207            if (port == sLinkID1)
    208            {
    209              /* yes. go get the frame. we know this call will succeed. */
    210               if ((SMPL_SUCCESS == SMPL_Receive(sLinkID1, msg, &len)) && len)
    211               {
    212                 /* Check the application sequence number to detect
    213                  * late or missing frames... 
    214                  */
    215                 tid = *(msg+1);
    216                 if (tid)
    217                 {
    218                   if (tid > sRxTid)
    219                   {
    220                     /* we're good. toggle LED in the message */
    221                     toggleLED(*msg);
    222                     sRxTid = tid;
    223                   }
    224                 }
    225                 else
    226                 {
    227                   /* the wrap case... */
    228                   if (sRxTid)
    229                   {
    230                     /* we're good. toggle LED in the message */
    231                     toggleLED(*msg);
    232                     sRxTid = tid;
    233                   }
    234                 }
    235                 /* drop frame. we're done with it. */
    236                 return 1;
    237               }
    238            }
    239            /* keep frame for later handling. */
    240            return 0;
    241          }
    242          

   Maximum stack usage in bytes:

     Function             CSTACK
     --------             ------
     linkTo                   6
       ->   Indirect call     6
       -> MRFI_DelayMs        6
       -> SMPL_Link           6
       -> toggleLED           6
       -> SMPL_Ioctl          6
       -> MRFI_DelayMs        6
       ->   Indirect call     6
       -> SMPL_Send           6
       ->   Indirect call     6
       -> SMPL_Send           6
     main                     2
       -> BSP_Init            2
       -> SMPL_Init           2
       -> toggleLED           2
       -> toggleLED           2
       -> linkTo              2
     sRxCallback              2
     toggleLED                2


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     P1IN              1
     P1OUT             1
     sLinkID1          1
     main             42
     linkTo          146
     alarmed           1
     toggleLED        20
     sRxCallback       4

 
 212 bytes in segment CODE
   2 bytes in segment DATA16_AN
   2 bytes in segment DATA16_Z
 
 212 bytes of CODE memory
   2 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: 3
